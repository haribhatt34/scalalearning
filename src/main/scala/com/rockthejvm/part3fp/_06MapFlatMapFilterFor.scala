package com.rockthejvm.part3fp

object _06MapFlatMapFilterFor {
    
    // standard list introduction

    // 1. Map, FlatMap and Filter are HOF, they can another function as an argument.
    //      The argument they take is an anonymous function.
    // 2. Map, FlatMap and Filter, they return another Instance of the list, doesn't modify the existing one.
    // 3. As they returns a new instance, they can chained to operate together
    
    var aList = List(1, 2, 3)   // [1] -> [2] -> [3] -> Nil // [1, 2, 3]
    var aList_v2 = List.apply(1, 2, 3)  // same as above
    
    val firstElement = aList.head   // 1
    val restOfElements = aList.tail // List(2, 3) return a List of from the second element 
    
    // map - apply a method to all the elements of the list
    val anIncrementList = aList.map(x => x + 1)
    val anIncrementList_v2 = aList.map(_ + 1)
    
    // filter - filter element from the list
    // filter method takes predicate as an argument
    val onlyOddNumbers = aList.filter(_ % 2 != 0)
    val lessThanThree = aList.filter {
        x => x <= 3
    }
    val lessThanThree_v2 = aList.filter {
        _ <= 3
    }
    
    // flatMap
    // 1. create a flatMap
    val toPair = (x: Int) => List(x, x+1)
    // 2. run this flatMap on a list
    val aFlatMappedList = aList.flatMap(toPair) // [1, 2, 3, 3, 4]
    val aFlatMappedList_v2 = aList.flatMap{
        x => List(x, x+1)
    }
    val aFlatMappedList_v3 = aList.flatMap { x =>
        List(x, x + 1)
    }

    // all pairs between numbers 1, 2, 3 and letters 'a', 'b', 'c'
    val aTwoPairsFlatMap = List(1, 2, 3).flatMap(number => List('a', 'b', 'c').map(letter => s"$number$letter"))
    // the above can de-constructed as:
    //  1. for part:
    //      number => List('a', 'b', 'c').map(letter => s"$number$letter")
    def combination(number: Int):List[String] = {
        List('a', 'b', 'c').map(letter => s"$number$letter")
    }



    val combinationOne = combination(1)
    val combinationTwo = combination(2)
    val combinationThree = combination(3)
    // 2. List(1, 2, 3).flatMap(--part 1--)
    //      it provide an input from (1, 2, 3) one by one, so we get three lists:
    //          (1a, 1b, 1c)
    //          (2a, 2b, 2c)
    //          (3a, 3b, 3c)
    //      FlatMap then compresses all these lists into a single list.

    /* Note */
    // FlatMap above works more like a nested FOR loop

    // Using For Comprehensions for above
    // for every number in List(1, 2, 3)
    //      for every letter in the List('a', 'b', 'c')
    //          return a string as NumberLetter
    val aForComprehension = for {
        number <- List(1, 2, 3)
        letter <- List('a', 'b', 'c')
    } yield {
        s"$number$letter"
    }
    // below is the code generated by compiler for the aforComprehension. 
    // generated using 
    //      scalac -decompile ./target/scala-3.0.0/classes/com/rockthejvm/part3fp/_06MapFlatMapFilterFor.tasty

    // val aForComprehension: List[String] = List(1, 2, 3).flatMap(((number: Int) => List('a', 'b', 'c').map(((letter: Char) => StringContext.apply("", "", "").s(number, letter))))
    

    /**
     * Exercise
     * 1. val numbers = List(1, 2, 3, 4)
     *      val chars = List('a', 'b', 'c', 'd')
     *      val colors = List("black", "white", "red")
     *   All the possible combination of these list - "1a - black", "2a - black"..., "1b - black"..., "2a - black"....
     *   additionaly, we have applied a filter for generating with even numbers only
     */
    val numbers = List(1, 2, 3, 4)
    val chars = List('a', 'b', 'c', 'd')
    val colors = List("black", "white", "red")
    // below .filter can be replaced withFilter, works similar to it.
    // in the generator the similar code is expanded by compiler into .withFilter instead of .filter
    val combinations = numbers.filter(_ % 2 == 0).flatMap(number => chars.flatMap(char => colors.map(color => s"$number$char - $color")))

    /* Basic representation of above combinations expression
        lambda = num => chars.map(char => s"$num$char")
        [1, 2, 3, 4].flatMap(lambda) =
        lambda(1) = chars.map(char => s"1$char) = ["1a" , "1b", "1c" , "1d"]
        lambda(2) = chars.map(char => s"2$char) = ["2a", "2b", "2c", "2d"]
        lambda(3) = ..
        lambda(4) = ..

        since we are using flatMap, it will compression all these lists into a single list
        [1, 2, 3, 4].flatMap(lambda) = ["1a", "1b", "1c", "1d", "2a", "2b", "2c", "2d", .... ]
    */

    // for-comprehension = map + flatMap
    // below expression reads, for every number in numbers, every char in chars and every color in colors, 
    // create this expression s"$number$char - $color" for every combinations of them and return them all under the same collection
    // same as combinations
    val combinationsFor = for {
        // a flatMap chain
        // for filtering, we can add an 'if guard' like below in the generator
        number <- numbers   if number % 2 == 0   // generators
        // a flatmap chain
        char <- chars
        // a map chain 
        color <- colors
    } yield s"$number$char - $color"    // an EXPRESION
    
    // for-comprehension with Unit(with Side effects)
    // for every num in numbers, perform this expression println(num)
    for {
        num <- numbers
    } println(num)
    // below is same as above
    numbers.foreach(println)

    /**
     * Exercises
     * TODO 1. LList supports for comprehensions ?
     * 2. Implement a small collection of AT MOST ONE element - Maybe[A]
     *  - map
     *  - flatMap
     *  - filter
     */

    val testWithForComprehension = 
        for {
            x <- List(1, 2, 3) if x % 2 != 0    // generators
            y <- List(4, 5, 6)                  // generators
        } yield x *  y
    
    // same as below
    
    val testWithoutForComprehension = 
        List(1, 2, 3)
            .withFilter(_ % 2 != 0)
            .flatMap { x =>
                List(4, 5, 6).map(y => x * y)
            }
        
    /*
    whats happening:
    -   The if guards are converted into withFilter calls
    -   The generators are nested using flatMap
    -   The expression following yield is converted into a map
    
    Why For Comprehensions:
    -   improve readability (compare with without forComprehension code)
     */
        
    def main(args: Array[String]): Unit = {
        println(firstElement)
        println(restOfElements)
        println(anIncrementList)
        println(anIncrementList_v2)
        println(onlyOddNumbers)
        println(aFlatMappedList)
        println(combinations)
        println(combinationsFor)
        println(aTwoPairsFlatMap)
        println(combinationOne)
        println(combinationTwo)
        println(combinationThree)
        println("aForComprehension: " + aForComprehension)
    }
}

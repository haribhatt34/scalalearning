package com.rockthejvm.part2oop

object _11CaseClasses {
    
    // case classes - light weight data structures
    // when to use case classes - when creating class to store in collection with same functionality
    // else when want to use heavy classes don't use case class
    case class Person(name: String, age: Int)
    
    // 1 - class args are now fields
    // class constructor automatically promoted to fields
    val daniel = new Person("Daniel", 99) {
        // do some other stuff as normal class
    }
    val danielsAge = daniel.age
    
    // 2 - some elementary methods automatically generated by the compiler
    // toString & hashCode & equals
    val danielToString = daniel.toString // Person("Daniel", 99)
    
    // equals
    // equals defines the sameness of two instance of a same class
    val danielDuped = new Person("Daniel", 99)
    // since Person is a case class "equals" operator was generated and result is true
    // else for a normal class, equals by default uses reference for equality comparison, which can never be same
    val isSameDaniel = daniel == danielDuped
    
    // hashCode
    // very important of Map and Sets, are they are hashed, case class generate one for you
    
    // 3 - Utility methods - copy, productIterator
    val danielSimilar = daniel.copy()           // same as - new Person("Daniel", 99)
    val danielYounger = daniel.copy(age = 23)   // same as - new Person("Daniel", 23)
    
    // 4. CCs have Companion Objects
    val thePersonSingleton = Person
    // This Person companion object has some methods including ability to create new instances with an apply method
    // apply method was generated by compiler to automatically take the constructor arguments as the case class
    val daniel_v2 = Person.apply("Daniel_v2", 99)
    
    // 5 - CCs are serializable
    // use-case: Akka
    
    // 6 - CCs have extractor patterns for PATTERN MATCHING
    
    // 7 - CCs must have an argument
    //  although, can define a case class with argument parenthesis but without any args
    //  mostly used in the context of generic 
    //      - defines an empty class with a type, like we had EmptyLinkedList in LList, 
    case class CCWithArgListNoArgs()
    case class CCWithArgListNoArgs_v2[A]()
    
    // Case Object 
    //  - don't have any args like CC
    //  - have compiler automatically generated toString, equals & hashCode
    //  - are serializable
    case object UnitedKingdom {
        // fields and methods
        def name: String = "The UK of GB and NI"
    }
    
    // Why "case class" must have an argument but "case object" is not required to do so
    /*
        case class CCWithNoArgs{
            // some code
        }
        
        val ccna = new CCWithNoArgs
        val ccna_v2 = new CCWithNoArgs  // instance would be equal!, as equality is based on fields data
        
        for case object they are singleton by nature already, i.e. only 1 object is there
    */

    //TODO
    /**
     * Exercise: use case classes for LList.
     * 
     */

    def main(args: Array[String]): Unit = {
        println(daniel)
        println(isSameDaniel)
    }
}
